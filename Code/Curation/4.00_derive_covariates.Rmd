---
title: "Covariate Cleaning"
author: "Mia Charifson"
date: "2024-01-22"
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
knitr::opts_knit$set(root.dir = '/Users/miacharifson/Library/CloudStorage/OneDrive-NYULangoneHealth/Charifson Dissertation/')

library(tidyverse)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(tableone)
library(stringr)
library(arsenal)
library(naniar)
library(readxl)
```

```{r load}
pat_cohort <- read.csv('Data/Derived/pat_cohort_w_censoring.csv')
ART_use <- read.csv('Data/Epic/table3_dx_ARTuse.csv')
empy_status <- read.csv('Data/Epic/table6_empy_status.csv')
enc_info_baseline <- read.csv('Data/Epic/table6_enc_info_baseline.csv')
ethnicity <- read.csv('Data/Epic/table6_ethnicity.csv')
marital <- read.csv('Data/Epic/table6_marital_status.csv')
ob_baseline <- read.csv("Data/Epic/table6_ob_baseline.csv")
race <- read.csv('Data/Epic/table6_race.csv')
edu <- read.csv('Data/Epic/table6_social_edu.csv')
lang_nativity <- read.csv('Data/Epic/table6_lang_nativity.csv')
occupn <- read.csv('Data/Epic/table6_occupn_baseline.csv')
insur_baseline <- read.csv('Data/Epic/table6_insurance_baseline.csv')
hc_use_dx <- read.csv('Data/Epic/table3_dx_HCuse.csv')
hc_use_social <- read.csv('Data/Epic/table6_social_HCuse.csv')
prior_delivery_baseline <- read.csv('Data/Epic/table3_dx_prior_delivery.csv')
race_ethnic_map <- read_excel('Data/External/race_ethnicity_mapping.xlsx', 1)
dx_outcomes <- read.csv('Data/Epic/table3_dx_outcomes.csv')
```

```{r functions}
# print percent pretty
print_percent <- function(number) {
  return(paste0(round(number, 3)*100, '%'))
}
# clean NULL to NA and subset covariate files to pat cohort
subset_clean <- function(df) {
  return(df %>% 
           filter(pat_id %in% pat_cohort$pat_id) %>%
           mutate(across(where(is.character), ~na_if(., "NULL")))
         )
}
# check unique number of patients
check_unique <- function(df) {
  if (length(unique(df$pat_id))[1]==dim(df)[1]) {
    reply <- "CHECK PASSED, UNIQUE ROW PER PATIENT"
  } else {
    reply <- "CHECK FAILED, MORE THEN ONE ROW FOR SOME PATIENTS"
  }
  return(print(reply))
}
```

# Covariate Cleaning

The purpose of this document is to:

(1) derive covariates that are not pre-specified in the data which includes:

- Hospital Site
- Healthcare utilization (HCU)
- Socioeconomic variables (educational attainment & employment)
- Insurance status
- ART use
- Hormonal Contraceptive Use


Additional covariates already derived but that need to be cleaned are: 

- Race/ethnicity
- Age
- Parity
- Preferred Language
- Marital status
- Hormonal contraceptive use
- Nativity/Immigration Status
- BMI
- Adenomyosis diagnosis

(2) explore distributions of the covariates

(3) explore missingness of the covariates

## 1: Derive Covariates {.tabset}

```{r clean_all}
enc_info_baseline <- subset_clean(enc_info_baseline) %>% mutate(bmi = as.numeric(bmi))
hc_use_social <- subset_clean(hc_use_social) 
ob_baseline <- subset_clean(ob_baseline) %>% 
  select(-pat_enc_csn_id, -contact_date, -index_enc_date, -margin, -rwn) %>%
  mutate(across(contains('ob'), ~as.numeric(.)))
lang_nativity <- subset_clean(lang_nativity)
insur_baseline <- subset_clean(insur_baseline)
marital <- subset_clean(marital) 
edu <- subset_clean(edu) 
empy_status <- subset_clean(empy_status) 
prior_delivery_baseline <- subset_clean(prior_delivery_baseline) 
```

### Primary Encounter Location

Hospital site was defined at baseline and during follow-up. The hospital site chosen was the most common hospital site for relevant care encounters in the first two years of follow-up (before 2019-12-31) and following the first two years of follow-up until the end of follow-up. 

If a hospital site was available as the most common site, this was selected. However, if the patient ONLY attended relevant care encounters at outpatient clinics. Their site was specified as "OTHER". We also allow a patient's most common 'site' to be telemedicine, as this is informative to where and how they receive their care.

### Healthcare utilization

Healthcare utilization at baseline and throughout follow-up was derived in step 1.0. 

Healthcare utilization at baseline is defined as the number of relevant care encounters in the first year since their index encounter. If they have none, their value is set to 0. 

Healthcare utilization throughout follow-up is defined as the number of relevant care encounters per calendar year (including the first year).

### Educational attainment

There are `r length(unique(edu$pat_id))` patients with any educational attainment information. 

```{r clean_edu}
clean_edu <- edu %>% 
  mutate(across(where(is.character), ~na_if(., "NULL"))) %>%
  filter(!is.na(edu_level) | !is.na(years_education)) %>%
  left_join(pat_cohort %>% select(pat_id, age_20160801, index_enc_date), by = 'pat_id') %>%
  mutate(margin = abs(difftime(index_enc_date, contact_date, units='day')))
```

These come in the form of highest level of education (categorical) (n=`r length(unique(clean_edu$pat_id[!is.na(clean_edu$edu_level)]))` unique patients report) and number of years of education (free text) (n=`r length(unique(clean_edu$pat_id[!is.na(clean_edu$years_education)]))` unique patients report). 

This doesn't seem worth it to clean since only `r print_percent(length(unique(edu$pat_id))/dim(pat_cohort)[1])`% of patients have anything to clean at all. 

```{r archive_edu_1, eval=FALSE}
edu_new <- edu %>% 
  mutate(across(where(is.character), ~na_if(., "NULL"))) %>%
  filter(!is.na(edu_level) | !is.na(years_education))
#unique(edu$edu_level)
#length(unique(edu$pat_id[!is.na(edu$years_education) & is.na(edu$edu_level)]))
#length(unique(edu$pat_id[!is.na(edu$edu_level)]))

below_GED <- c('11th grade', '8th grade')
GED_equivalent <- c('GED or equivalent', '12th grade', 'High school graduate')
some_college <- c('Some college, no degree', 'Associate degree: occupational, technical, or vocational program', "Associate degree: academic program")
college <- c("Bachelor's degree (e.g., BA, AB, BS)")
some_grad_school <- c("Master's degree (e.g., MA, MS, MEng, MEd, MSW, MBA)", 
                      "Professional school degree (e.g., MD, DDS, DVM, JD)",
                      "Doctorate")

edu_new <- edu_new %>%
  mutate(edu_level_new = case_when(edu_level %in% below_GED ~ 'Below GED', 
                                   edu_level %in% GED_equivalent ~ 'GED or equivalent', 
                                   edu_level %in% some_college ~ 'Some college (including associates)',
                                   edu_level %in% college ~ 'College (BA, AB, BS)', 
                                   edu_level %in% some_grad_school ~ 'Any graduate schooling',
                                   TRUE~NA))
  
CreateTableOne(data=edu_new %>% filter(!is.na(edu_level)), vars=c('edu_level', 'edu_level_new'))
```

```{r archive_edu_2, eval=FALSE}
edu_new %>%
  left_join(pat_cohort %>% select(pat_id, age_20160801), by='pat_id') %>%
  filter(!is.na(years_education)) %>%
  mutate(years_edu_num = as.numeric(str_extract(years_education, '[0-9]+')),
         year_type = case_when(grepl('grade|th', tolower(years_education))~'grade',
                               grepl('(?:year|yr).*(coll)',tolower(years_education),perl=TRUE)~'college',
                               TRUE~NA)) %>%
  filter(years_edu_num == 12 & year_type == 'grade') %>%
  select(pat_id, age_20160801, years_education, years_edu_num, year_type) %>%
  distinct() %>%
  arrange(desc(age_20160801))
  #filter(!is.na(years_edu_num)) %>% group_by(years_education, years_edu_num, year_type) %>% 
  #summarise(count=n(), .groups='drop') %>% arrange(year_type, years_edu_num) %>%
  mutate(edu_level_new = case_when(years_edu_num %in% c(1:11) & 
                                     year_type == 'grade'~'Below GED', 
                                   years_edu_num %in% c(12, 112) & 
                                     year_type == 'grade'~'GED or equivalent', 
                                   years_edu_num %in% c(13:15)~'Some college',
                                   years_edu_num %in% c(1:3) & 
                                     year_type == 'college'~'Some college',
                                   years_edu_num >= 16 ~'College or higher',
                                   years_edu_num==4 & 
                                     year_type == 'college' ~'College or higher',
                                   grepl(grad_strings, years_education)~'College or higher')) %>%
  CreateTableOne(data=., vars='edu_level_new', includeNA=TRUE)
```

```{r archive_edu_3, eval=FALSE}
# 11th grade
edu_new$years_edu_clean[grepl('5th|8th|9th|10th|11th', tolower(edu_new$years_education))] <- 'Below GED'
edu_new$years_edu_clean[grepl('high s', tolower(edu_new$years_education)) 
                               & grepl('sen|some|junior|last|ing', tolower(edu_new$years_education))] <- 'Below GED' 
# 12th grade
edu_new$years_edu_clean[grepl('12', tolower(edu_new$years_education))] <- 'GED or equivalent'
edu_new$years_edu_clean[grepl('high s', tolower(edu_new$years_education)) 
                               & !grepl('sen|some|junior|last|ing', tolower(edu_new$years_education))] <- 'GED or equivalent' 
# some college
edu_new$years_edu_clean[grepl('some|year|yr|in|freshman|junior', tolower(edu_new$years_education)) 
                        & !grepl('prep|finished|complete', tolower(edu_new$years_education))
                        & grepl('coll|assoc', tolower(edu_new$years_education)) ] <- 'Some college, including Associates'
# bachelors
edu_new$years_edu_clean[grepl('bac|BA|BS|Bach', edu_new$years_education) 
                        & !grepl('MBA|-BBA|BBA-', edu_new$years_education)] <- 'College (BA, AB, BS)'
edu_new$years_edu_clean[!grepl('some|year|yr|in|freshman|junior|prep|jr', tolower(edu_new$years_education)) 
                        & grepl('coll', tolower(edu_new$years_education))] <- 'College (BA, AB, BS)'
# master's
edu_new$years_edu_clean[grepl('MA|mas|Mas|MAS|MS', edu_new$years_education) 
                        & !grepl('NMS', edu_new$years_education)] <- 'Any graduate schooling'
# graduate school
grad_strings <- c('doct|grad school|law|medical|graduate level|graduate school|meng|msw|mba|mph|phd|ph. d|ph.d|md|jd|dds|dvm|ma|ms|ba|bs')
edu_new$years_edu_clean[grepl(grad_strings, tolower(edu_new$years_education))] <- 'Any graduate schooling'
```

```{r archive_edu_4, eval=FALSE}
CreateTableOne(data=edu_new, vars=c('years_edu_clean'), includeNA = TRUE)
#unique(edu_new$years_education[which(is.na(edu_new$years_edu_clean))])
```

### Employment Status

There are `r length(unique(empy_status$pat_id))` patients with employment status information and `r length(unique(occupn$pat_id[which(!is.na(occupn$hx_occupn))]))` with occupation information. 

```{r clean_empy}
empy_clean <- empy_status %>%
  left_join(pat_cohort %>% select(pat_id, index_enc_date), by='pat_id') %>%
  mutate(margin = difftime(change_time, index_enc_date, unit='days'),
         margin = as.numeric(margin),
         old_empy_status = case_when(grepl('NULL|Unknown', old_empy_status)~NA,
                                        TRUE~old_empy_status),
         new_empy_status = case_when(grepl('NULL|Unknown', new_empy_status)~NA,
                                        TRUE~new_empy_status)) %>%
  group_by(pat_id) %>%
  filter(min(abs(margin)) == abs(margin)) %>%
  ungroup() %>%
  # if either is missing take the one that isn't missing, otherwise take according to date
  mutate(employ_clean = case_when(is.na(old_empy_status) | is.na(new_empy_status)~
                                               coalesce(new_empy_status, old_empy_status),
                                             index_enc_date < change_time~old_empy_status, 
                                             index_enc_date >= change_time~new_empy_status)) %>%
  filter(!is.na(employ_clean)) %>%
  select(pat_id, employ_clean, margin) %>%
  mutate(source = 'empy_status')
```

After cleaning the employment status table, there are `r length(unique(empy_clean$pat_id))` patients had an employment status at some point, which we can use for their baseline employment status. 

`r length(which(empy_clean$margin > 0))` are employment statuses reported after their index encounter.

```{r test_occupn_strings, eval=FALSE}
unique(occupn$hx_occupn[which(grepl('none|not|unem|n/a|umep|unep|disable|disability',
                                     tolower(occupn$hx_occupn)) &
                                 !grepl('art|work|dame|analyst|sales', tolower(occupn$hx_occupn)))])
unique(occupn$hx_occupn[which(occupn$hx_occupn=="" | occupn$hx_occupn==".")])
unique(occupn$hx_occupn[which(grepl('part ', tolower(occupn$hx_occupn)))])
unique(occupn$hx_occupn[which(grepl('retired', tolower(occupn$hx_occupn)))])

unique(occupn$hx_occupn[which(grepl('no empleo|nort em|nt em', tolower(occupn$hx_occupn)))])
```

```{r clean_occupn}
umemployed_strs <- c('none|not|unem|n/a|umep|unep|disabled|disability|no empleo|nort em|nt em')

occupn_clean <- occupn %>% 
  select(pat_id, hx_occupn, margin) %>%
  distinct() %>%
  mutate(occupn_clean = case_when(hx_occupn == '   ' | hx_occupn == '.'~NA, 
                                  grepl('prefer|refuse|discuss', tolower(hx_occupn))~NA,
                                  TRUE~tolower(hx_occupn)),
         employ_clean = case_when(grepl('student', occupn_clean)~'Student',
                                     grepl('part ', occupn_clean)~'Part Time',
                                     grepl('self em|self-em', occupn_clean)~'Self Employed',
                                     grepl('retired', occupn_clean)~'Retired',
                                     grepl(umemployed_strs,occupn_clean) &
                                       !grepl('art|work|dame|analyst|sales',occupn_clean)~'Not Employed',
                                     !is.na(occupn_clean)~'Employed (unspecific)',
                                     TRUE~NA)) %>%
  filter(!is.na(employ_clean)) %>%
  select(pat_id, employ_clean, margin) %>%
  mutate(source = 'occupn_hx')
```

```{r final_empy}
employment_final <- empy_clean %>%
  bind_rows(occupn_clean) %>%
  group_by(pat_id) %>%
  filter(margin == min(margin)) %>%
  mutate(employ_simple_final = case_when(employ_clean %in% c('Employed (unspecific)', 'On Active Military Duty',
                                                             'Full Time', 'Self Employed', 'Part Time')~'Employed',
                                         grepl('Student', employ_clean)~'Student',
                                         TRUE~employ_clean))
```

```{r check_unique_empy}
check_unique(employment_final)
```

The occupation history data filled in some of the missing data (whichever employment information that had the smallest margin was selected). Overall, we have good coverage of employment status at baseline in this cohort (`r print_percent(dim(employment_final)[1]/dim(pat_cohort)[1])`% of patients).

```{r, eval=FALSE}
employment_final %>%
  filter(!is.na(empy_status_baseline) & !is.na(empy_status_new)) %>%
  select(pat_id, emply_final, empy_status_baseline, margin, empy_status_new)
```

### Insurance status

In 2017, the percent of US Americans on some kind of public health insurance was 34-37% (based on US Census data[https://www.census.gov/content/dam/Census/library/publications/2022/demo/p60-278.pdf]) This includes medicare, medicaid, VA, CHAMPVA plans and NYS specific plans (child & family health plus, managed care plans, essential plans).

There are some index encounters with missing insurance information. They are predominantly from FHC encounters. It is unclear if this is because the patient had no insurance or it was not entered for another reason. 

```{r clean_insur}
insur_baseline_unique <- insur_baseline %>%
  mutate(pat_enc_csn_id = as.character(pat_enc_csn_id),
         enc_date = as.Date(enc_date, '%Y-%m-%d')) %>%
  inner_join(pat_cohort %>% 
               select(pat_id, all_pat_enc_csn_id, index_enc_date) %>%
               mutate(index_enc_date = as.Date(index_enc_date, '%Y-%m-%d')), 
             by=c('pat_id'='pat_id', 'enc_date'='index_enc_date'))
```

For insurance status at baseline, I used the plan names to map to public plans and assumed all other patients with plans at baseline are private plans. 

```{r, eval=FALSE}
length(unique(insur_baseline$payor_name))
length(unique(insur_baseline$benefit_plan_name))

length(which(grepl('medicare', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('medicare', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('medicaid', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('medicaid', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('managed', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('managed', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('family health', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('family health', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('veteran', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('veteran', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('champva', tolower(unique(insur_baseline$benefit_plan_name)))))

length(which(grepl('child health', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('child health', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('essential', tolower(unique(insur_baseline$benefit_plan_name)))))
unique(insur_baseline$benefit_plan_name)[which(grepl('essential', tolower(unique(insur_baseline$benefit_plan_name))))]

length(which(grepl('healthy new york', tolower(unique(insur_baseline$benefit_plan_name)))))
```

```{r public_plan_mapping}
public_plans <- 'medicare|medicaid|family health|veteran|champva|healthy new york|child health|essential|healthfirst|metroplus|mcd|1199'

insur_clean <- insur_baseline_unique %>%
  filter(!is.na(benefit_plan_name)) %>%
  mutate(insur_status = case_when(grepl(public_plans, tolower(benefit_plan_name))~'public',
                                  TRUE~'private')) %>%
  distinct(pat_id, enc_date, payor_name, benefit_plan_name, insur_status, .keep_all = TRUE)

# length(which(insur_clean$insur_status == 'public'))/dim(insur_clean)[1]
# checking percent matches the national/state average
```

```{r, eval=FALSE}
insur_clean %>%
  filter(insur_status == 'private') %>%
  distinct(payor_name, benefit_plan_name)
```

```{r check_unique_insur}
check_unique(insur_clean)
```

```{r insur_unique_final}
insur_clean_unique <- insur_clean %>%
  distinct(pat_id, enc_date, insur_status)

check_unique(insur_clean_unique)
```

Overall coverage of insurance status at baseline in this cohort: `r print_percent(dim(insur_clean_unique)[1]/dim(pat_cohort)[1])`% of patients.

### Assisted Reproductive Technology (ART) Use

For ART use, we are interested in (1) if a patient had use ART prior to baseline and (2) if they use ART at some point during follow-up (if they do receive ART care during FU then we also want to record the date of the earliest ART). We assume that if they do not have any diagnosis codes for ART in their EHR then they do not have ART use. This is a strong assumption given that patients can receive ART care outside of NYU, but we assume this would be indicated somewhere in their EHR considering they receive regular and relevant care at NYU.

```{r clean_ART}
remove_ART <- "Conceived by in vitro fertilization|History of in vitro fertilization"  

ART_clean <- ART_use %>%
  filter(!grepl(remove_ART, dx_name)) %>%
  left_join(pat_cohort %>% select(pat_id, index_enc_date), by='pat_id') %>%
  mutate(dx_date = as.Date(dx_date),
         dx_window = case_when(dx_date <= index_enc_date~'baseline',
                               TRUE~'fu')) %>%
  group_by(pat_id, dx_window) %>%
  reframe(ART_use = sum(!is.na(dx_date))>=1, 
            ART_use_date = pmin(dx_date, na.rm = TRUE)) %>%
  pivot_wider(names_from = dx_window, values_from = c(ART_use, ART_use_date),
              values_fn = mean) %>%
  mutate(ART_use_baseline = ifelse(ART_use_baseline==1, TRUE, FALSE),
         ART_use_fu = ifelse(ART_use_fu==1, TRUE, FALSE))
```

```{r check_unique_ART_2}
check_unique(ART_clean)
```

Patients with indications of ART use in this cohort: `r print_percent(dim(ART_clean)[1]/dim(pat_cohort)[1])`% of patients.

### Race and Ethnicity 

When cleaning the race and ethnicity data for missingness I use the following assumptions: 

1. If race is missing but ethnicity is not missing and is not set to 'Hispanic/Latino' or 'Non-Hispanic/Latino', then race is set to the value of ethnicity. 
- Limitation: this assumes only partial info on this patient's race given they could have other unreported racial groups. 

2. If ethnicity is missing but race = 'Hispanic/Latino', then ethnicity is set to 'Hispanic/Latino'.

3. If ethnicity or race is anything other than 'Hispanic/Latino' more than once (they enter their race or ethnicity multiple times and multiple times do not indicate Hispanic/Latino), then their ethnicity is assumed to be 'Non-Hispanic/Latino'.
- Limitation: this does not impute ethnicity for patient's with race reported only once, but makes an assumption based on the quantity of data.

4. In the merged race and ethnicity variable, we make the following choices:
- if someone reports more than one race, then they are labelled 'Multiple races'
- if someone reports being Hispanic/Latino, then they are labelled 'Hispanic/Latino', therefore all race categories are labelled as non-Hispanic (NH)

```{r clean_race_ethnic, warning=FALSE}
# recode the name information
race_ethnic_map$name <- stringi::stri_encode(race_ethnic_map$name, to = 'ASCII')
race_ethnic_map$name <- str_replace_all(race_ethnic_map$name , "\032", " ")
race_ethnic_map$ethnicity_category <- stringi::stri_encode(race_ethnic_map$ethnicity_category, to = 'ASCII')
race_ethnic_map$ethnicity_category <- str_replace_all(race_ethnic_map$ethnicity_category , "\032", " ")
race_ethnic_map$race_category <- stringi::stri_encode(race_ethnic_map$race_category, to = 'ASCII')
race_ethnic_map$race_category <- str_replace_all(race_ethnic_map$race_category , "\032", " ")

# get distinct instances of race, ethnicity and number of times the patient indicated that identity
race_new <- race %>%
  distinct(pat_id, race_name) %>%
  rename(name = race_name) %>%
  left_join(race_ethnic_map, by='name') %>%
  mutate(across(where(is.character), ~na_if(., "NULL")))

# use ethnicity and raw_ethnicity_group
ethnic_new <- ethnicity %>%
  distinct(pat_id, ethnicity) %>%
  rename(name = ethnicity) %>%
  left_join(race_ethnic_map, by='name') %>%
  mutate(across(where(is.character), ~na_if(., "NULL"))) %>%
  left_join(ethnicity %>% distinct(pat_id, raw_ethnicity_group), by='pat_id') 

# check if raw_ethnicity_group can fill in any gaps
length(which(is.na(ethnic_new$ethnicity_category) & !is.na(ethnic_new$raw_ethnicity_group))) #1455

# back fill with raw_ethnicity_group
ethnic_new <- ethnic_new %>%
  mutate(ethnicity_category = case_when(!is.na(ethnicity_category)~ethnicity_category,
                                        raw_ethnicity_group == 'Not of Spanish/Hispanic Origin'~
                                          raw_ethnicity_group,
                                        raw_ethnicity_group %in% 
                                          c('Spanish/Hispanic Origin', 'Other Hispanic, Latino/a, or Spanish Origin')~ 'Hispanic, Latino or Spanish Origin')) %>%
  select(-raw_ethnicity_group)

# join together
race_ethnic <- rbind(race_new, ethnic_new)
```

```{r race_ethnic_dummy}
race_dum <- race_ethnic %>%
  filter(pat_id %in% pat_cohort$pat_id) %>%
  distinct(pat_id, race_category) %>%
  filter(!is.na(race_category)) %>%
  mutate(value = TRUE,
         race_category = case_when(race_category == 'Middle Eastern or North African'~'MENA',
                                   race_category=='Native American, First Peoples, or Alaskan Native'~
                                     'native',
                                   race_category == 'Native Hawaiian or Pacific Islander'~'NHPI',
                                   TRUE~race_category)) %>%
  pivot_wider(names_from = race_category, values_from = value, names_prefix = 'race_') %>%
  mutate(across(race_White:race_MENA, ~replace_na(., FALSE))) 

ethnic_dum <- race_ethnic %>% 
  distinct(pat_id, ethnicity_category) %>%
  filter(!is.na(ethnicity_category)) %>%
  group_by(pat_id) %>%
  summarise(Hispanic = case_when(sum(ethnicity_category == 'Hispanic, Latino or Spanish Origin',
                                  na.rm=TRUE)>=1~TRUE,
                                 sum(!is.na(ethnicity_category))>=1~FALSE,
                                 TRUE~NA), .groups='drop')
```

```{r fhc_race_fill_in}
# check if there are any that can be filled in the FHC data

# FHC race values for ethnicity
fhc_race1 <- race %>% 
  left_join(race_dum, by='pat_id') %>%
  filter(is.na(race_White) & !fhc_race_group %in% c('Unreported/Refused to Report Race',
                                                    'Unmapped', 'Hispanic/Latino')) %>%
  mutate(fhc_race_group = factor(fhc_race_group, labels = c('native', 'Asian', 'Black', 
                                                            'NHPI', 'NHPI', 'White'))) %>%
  distinct(pat_id, fhc_race_group) %>%
  mutate(value = TRUE, fhc_race_group = as.character(fhc_race_group)) %>%
  pivot_wider(names_from = fhc_race_group, values_from = value, names_prefix = 'race_') %>%
  mutate(across(race_Asian:race_NHPI, ~replace_na(., FALSE))) 

# FHC ethnicity values for race
fhc_race2 <- ethnicity %>% 
  left_join(race_dum, by='pat_id') %>%
  filter(is.na(race_White) & !fhc_value %in% c("Hispanic/Latino", 
                                                   "Non-Hispanic/Latino",
                                                   "Unreported/Refused to Report Race",
                                                   "Unreported/Refused to Report Ethnicity",
                                                   "Unmapped")) %>%
  mutate(fhc_value = factor(fhc_value, labels = c('native', 'Asian', 'Black', 'NHPI', 'White'))) %>%
  distinct(pat_id, fhc_value) %>%
  mutate(value = TRUE, fhc_value = as.character(fhc_value)) %>%
  pivot_wider(names_from = fhc_value, values_from = value, names_prefix = 'race_') %>%
  mutate(across(race_Black:race_NHPI, ~replace_na(., FALSE))) 

# join them and collapse duplicates
fhc_race <- rbind(fhc_race1, fhc_race2) %>% 
  distinct() %>%
  group_by(pat_id) %>%
  summarise(race_Asian = any(race_Asian),
            race_Black = any(race_Black),
            race_White = any(race_White),
            race_native = any(race_native),
            race_NHPI = any(race_NHPI), .groups='drop') %>%
  mutate(race_MENA = FALSE)

# add to race_dum
race_dum <- rbind(race_dum, fhc_race)
```

```{r fhc_ethnicity_fill}
# FHC race values for ethnicity -- n=0 so don't need this
# race %>% left_join(ethnic_dum, by='pat_id') %>%
#   filter(is.na(Hispanic) & fhc_race_group == "Hispanic/Latino") %>%
#   mutate(fhc_race_group = factor(fhc_race_group)) %>%
#   nrow()

# FHC ethnicity values for ethnicity
fhc_ethnicity <- ethnicity %>% 
  left_join(ethnic_dum, by='pat_id') %>%
  filter(is.na(Hispanic) & fhc_value %in% c("Hispanic/Latino", "Non-Hispanic/Latino")) %>%
  mutate(fhc_value = factor(fhc_value)) %>%
  group_by(pat_id) %>%
  summarise(Hispanic = case_when(sum(fhc_value == "Hispanic/Latino",na.rm=TRUE)>=1~TRUE,
                                 sum(!is.na(fhc_value))>=1~FALSE), .groups='drop')

# add to ethnicity_dum
ethnic_dum <- rbind(ethnic_dum, fhc_ethnicity)
```

```{r join_race_ethnic}
race_ethnic_dum <- race_dum %>%
  full_join(ethnic_dum, by='pat_id') %>%
  rowwise() %>% 
  mutate(multiple_races = sum(race_White,race_Black,race_Asian,race_native,race_NHPI,race_MENA,
                              na.rm = T)) %>%
  ungroup()
```

```{r race_ethnic_dummy_old, eval=FALSE, include=FALSE}
race_ethnic_dum <- race_ethnic %>%
  filter(pat_id %in% pat_cohort$pat_id) %>%
  group_by(pat_id) %>%
  summarise(race_Black = case_when(sum(grepl('Black', race_category), na.rm=TRUE)>=1~TRUE,
                                   sum(grepl('Black', race_category), na.rm=TRUE)==0~FALSE,
                                   TRUE~NA),
            race_Asian = sum(grepl('Asian', race_category), na.rm=TRUE)>=1,
            race_White = sum(grepl('White', race_category), na.rm=TRUE)>=1,
            race_MENA = sum(grepl('Middle Eastern or North African', race_category), na.rm=TRUE)>=1,
            race_Native = sum(grepl('Native American, First Peoples, or Alaskan Native', race_category), na.rm=TRUE)>=1,
            race_NHPI = sum(grepl('Native Hawaiian or Pacific Islander', race_category), na.rm=TRUE)>=1, 
            Hispanic = case_when(sum(ethnicity_category == 'Hispanic, Latino or Spanish Origin', na.rm=TRUE)>=1~TRUE,
                                 sum(!is.na(ethnicity_category))>=1~FALSE,
                                 TRUE~NA),
            .groups='drop') %>%
  rowwise() %>% 
  mutate(multiple_races = sum(c_across(race_Black:race_NHPI), na.rm = T)) %>%
  ungroup()
```

```{r race_ethnic_summary, results='asis'}
# look at race and ethnicity
race_ethnic_dum %>%
  tableby(formula=~race_Black+race_Asian+race_White+race_MENA+race_native+race_NHPI+Hispanic, 
          data=., test=FALSE) %>%
  summary()
```

There are `r length(which(race_ethnic_dum$multiple_races>1))` patients who reported multiple races. The common combinations are: 

```{r multiple_race_combos}
race_ethnic_dum %>%
  filter(multiple_races>1) %>%
  select(-Hispanic, -multiple_races) %>%
  rowwise() %>% 
  mutate(race_all = paste0(names(.[-1])[c_across(race_White:race_MENA) == TRUE], collapse = ' '),
         race_all = gsub('race_', '', race_all)) %>%
  group_by(race_all) %>%
  summarise(count=n(), .groups='drop') %>%
  arrange(desc(count)) %>%
  head(10) %>%
  kable(caption = 'Top ten racial combinations of multiracial patients') %>% 
  kable_styling()
```

```{r merge_race_ethnic}
# apply multiple race logic
r1 <- race_ethnic_dum %>% 
  filter(multiple_races > 1) %>%
  mutate(race_final = 'Multiple Races') %>%
  select(pat_id, race_final)

# grab race for those with only one TRUE race
r2 <- race_ethnic_dum %>% 
  filter(multiple_races == 1) %>%
  select(-multiple_races) %>%
  pivot_longer(cols=contains('race'), names_to='race', names_prefix = 'race_', values_to = 'value') %>%
  filter(value) %>% 
  mutate(race_final = race) %>%
  select(pat_id, race_final)

# join all together
race_ethnic_final <- race_ethnic_dum %>% 
  mutate(ethnicity_final = case_when(Hispanic~'Hispanic/Latino',
                                     !Hispanic~'Non-Hispanic/Latino')) %>%
  select(pat_id, ethnicity_final) %>%
  full_join(rbind(r1, r2), by = 'pat_id') %>%
  mutate(race_ethnic_final = case_when(ethnicity_final=='Hispanic/Latino'~ethnicity_final,
                                       !is.na(race_final)~str_c('NH ', race_final)))
```

```{r check_unique_race_ethnic}
check_unique(race_ethnic_final)
```

Overall coverage of race-ethnicity status at baseline in this cohort: `r print_percent(length(which(!is.na(race_ethnic_final$race_ethnic_final)))/dim(pat_cohort)[1])` of patients.

```{r, eval=FALSE}
test <- pat_cohort %>% select(pat_id) %>% left_join(race_ethnic_final, by='pat_id')

length(which(is.na(test$race_final)))
length(which(is.na(test$ethnicity_final)))
length(which(is.na(test$race_ethnic_final)))
```


### Hormonal Contraceptive (HC) Use

Hormonal contraceptive (HC) use is defined as use of any form of hormonal contraceptive (IUD, pill, injectable, implant, patch, ring) at the time of baseline or close to the time of baseline (within one year). The two sources for HC use are (1) indication of some type of HC use in the social baseline table or (2) diagnosis code for prescription for or surveillance of HC. Both of these are ONLY positive indicators of HC use. This means we will likely have many false negatives by missing indication of HC use if they are not prescribed at NYU and not recorded in the social baseline survey for patients. 

We take any positive indication from either source to count. Positive indication for each is defined as: 

- social baseline survey: (1) is their index encounter between the start/check-up date for an HC and another HC social history indicator? or (2) in the year after baseline encounter, do they have any true HC screen? This means at some point in the baseline year following entry into cohort they used a HC. 
- diagnosis codes: (1) is their index encounter between the start/check-up date for an HC and another HC encounter (of any type)? or (2) in the year after baseline encounter, do they have any encounter for HC (this includes starting, continuing or ending HC use)? This means at some point in the baseline year following entry into cohort they used a HC. 

```{r clean_hc_social}
hc_social_clean <- hc_use_social %>% 
  inner_join(pat_cohort %>% select(pat_id, index_enc_date), by='pat_id') %>%
  mutate(contact_date = as.Date(contact_date), index_enc_date = as.Date(index_enc_date)) %>%
  group_by(pat_id) %>%
  mutate(next_hc_enc = lead(contact_date),
         HC_status = case_when((index_enc_date >= contact_date & index_enc_date <= next_hc_enc)~TRUE,
                               between(as.numeric(contact_date-index_enc_date), 0, 365) ~ TRUE,
                               TRUE~FALSE),
         source = 'social_history')
#length(unique(hc_social_clean$pat_id[which(hc_social_clean$HC_status)]))
```

```{r clean_hc_dx}
hc_dx_clean <- hc_use_dx %>% 
  filter(!grepl('condom|barrier', tolower(dx_name))) %>%
  inner_join(pat_cohort %>% select(pat_id, index_enc_date), by='pat_id') %>%
  mutate(dx_date = as.Date(dx_date), index_enc_date = as.Date(index_enc_date)) %>%
  arrange(pat_id, dx_date) %>%
  mutate(HC_enc_type = case_when(grepl('Z30.432', icd10)~'end',
                                 grepl('removal|pregnancy', tolower(dx_name)) & 
                                   !grepl('reinsertion', tolower(dx_name))~'end',
                                 TRUE~'not end'),
         hc_type = case_when(grepl('Z30.011|Z30.41', icd10)~'pill',
                                grepl('Z30.014|Z30.43[0-3]', icd10)~'iud',
                                grepl('Z30.013|Z30.42', icd10)~'injectable',
                                grepl('Z30.015|Z30.44', icd10)~'ring',
                                grepl('Z30.016|Z30.45', icd10)~'patch',
                                grepl('Z30.017|Z30.46', icd10)~'implant',
                                grepl('Z30.012', icd10)~'emergency',
                                grepl('bcp|oral|pill', tolower(dx_name))~'pill',
                                grepl('iud|intrauterine|uterin contracep dev',
                                      tolower(dx_name))~'iud',
                                grepl('depo|inject|medroxy', tolower(dx_name))~'injectable',
                                grepl('ring|intravaginal', tolower(dx_name)) &
                               !grepl('monitoring|occurring|during', dx_name)~'ring',
                                grepl('patch|transdermal', tolower(dx_name))~'patch',
                                grepl('implant|implanon|subdermal|nexplanon|norplant',
                                      tolower(dx_name))~'implant',
                                TRUE~'other')) %>% 
  filter(hc_type != 'emergency') %>%
  group_by(pat_id) %>%
  mutate(next_hc_enc = lead(dx_date),
         HC_status = case_when((index_enc_date >= dx_date & index_enc_date <= next_hc_enc) &
                                 HC_enc_type != 'end'~TRUE,
                               between(as.numeric(dx_date-index_enc_date), 0, 365) ~ TRUE,
                               TRUE~FALSE),
         source = 'diagnosis_codes') %>%
  ungroup()
```

```{r, eval=FALSE}
hc_dx_clean %>% 
  group_by(pat_id) %>% 
  filter(sum(HC_status)==0 & sum(year(dx_date)==year(index_enc_date))>=1) %>%
  select(-pat_enc_csn_id, -dx_type, -referral_id) %>%
  View()

hc_dx_clean %>% 
  group_by(pat_id) %>% 
  filter(HC_status) %>%
  select(-pat_enc_csn_id, -dx_type, -referral_id) %>%
  View()

## based on both sources how many contraceptive users should there be
length(unique(c(hc_dx_clean$pat_id[which(hc_dx_clean$HC_status)], hc_social_clean$pat_id[which(hc_social_clean$HC_status)])))
```

```{r join_hc}
hc_baseline_clean <- hc_social_clean %>% 
  filter(HC_status) %>%
  select(pat_id, HC_status, hc_type) %>%
  bind_rows(hc_dx_clean %>% 
              filter(HC_status) %>% 
              select(pat_id, HC_status, hc_type, source)) %>% 
  distinct() %>%
  group_by(pat_id) %>%
  # remove duplicates where the type is other or emergency in favor of the duplicate which is not that
  filter(n()==1 | (n()>1 & !hc_type %in% c('other', 'emergency'))) %>%
  summarise(HC_status = case_when(sum(HC_status) >= 1~TRUE,
                                  n() == sum(!HC_status)~FALSE),
            HC_type = paste0(unique(hc_type[HC_status]), collapse = ', '),
            .groups='drop')
```

```{r check_unique_hc}
check_unique(hc_baseline_clean)
```

Patients with indications of HC information in this cohort: `r print_percent(dim(hc_baseline_clean)[1]/dim(pat_cohort)[1])`% of patients.

We assume if they do NOT have positive indication of HC use at baseline than they were not using HC at baseline (this likely underestimates the true rate and has high false negative rate).

This table shows the number of patients at baseline who were on some form of hormonal contraceptive and the methods of contraceptive used. Some patients indicated multiple methods so they may sum to more than 100% of the patients with `HC_status=TRUE`.

```{r hc_table, results='asis'}
hc_baseline_clean %>%
  mutate(iud = ifelse(grepl('iud', HC_type), TRUE, FALSE),
         pill = ifelse(grepl('pill', HC_type), TRUE, FALSE),
         other = ifelse(grepl('implant|injection|ring|patch', HC_type), TRUE, FALSE)) %>%
  tableby(formula = ~iud+pill+other, data=.) %>%
  summary()
```

### Parity

Parity is derived from the obstetric history questionnaire (voluntary completed for a patient) or via any indication of prior delivery in diagnosis codes prior to 2017-12-31. 

If they have parity > 0 or indiciation of a prior delivery before end of baseline, they are considered parous. If they have a parity = 0, they are considered nulliparous.

We could also assume no indication of prior delivery means nulliparous, but given most patients who do have parity > 1 do not also have a prior indication of delivery, I think this would be a false assumption. 

```{r clean_parity}
parity_clean <- ob_baseline %>% 
  mutate(parity_final = coalesce(ob_parity, ob_live_births, ob_full_term)) %>%
  select(-contains('ob')) %>%
  full_join(prior_delivery_baseline %>% mutate(prior_delivery = as.logical(prior_delivery)), by='pat_id') %>%
  mutate(parity_binary = case_when(parity_final == 0~'nulliparous',
                                 parity_final >= 1~'parous',
                                 prior_delivery~'parous'))
```

```{r check_unique_parity}
check_unique(parity_clean)
```

Patients with indications of parity information in this cohort: `r print_percent(length(which(!is.na(parity_clean$parity_binary)))/dim(pat_cohort)[1])`% of patients.

```{r missing_parity_ages}
pat_cohort %>%
  mutate(parity_flag = ifelse(pat_id %in%
                                parity_clean$pat_id[which(!is.na(parity_clean$parity_binary))], 
                              TRUE, FALSE)) %>%
  ggplot(aes(x=age_20160801), data=.) +
  geom_histogram(fill='purple', color='black') +
  xlab('Age at baseline (yrs)') +
  facet_grid(~parity_flag) + 
  theme_bw()
```

There isn't a notable age pattern for patients missing parity. Those who are missing parity are on average about a year older but the overall mean and spread are very similar. 

### Preferred Language

```{r clean_lang}
language_clean <- lang_nativity %>% 
  select(pat_id, contains('language'), intrptr_needed_yn) %>% 
  distinct() %>%
  mutate(language = coalesce(language_prefer, language_care, language_writ)) %>%
  mutate(language = ifelse(grepl('DO NOT USE', language), NA, language)) %>%
  mutate(language_eng = case_when(language == 'English'~language, 
                                  intrptr_needed_yn == 'Y'~'Non-English',
                                  !is.na(language)~'Non-English'), 
         language_eng = factor(language_eng)) %>%
   mutate(language_eng_sp = case_when(language %in% c('English', 'Spanish')~language, 
                                  !is.na(language)~'Other'), 
         language_eng_sp = factor(language_eng_sp))
```

```{r check_unique_lang}
check_unique(language_clean)
```

Overall, we can extract preferred language for `r print_percent(dim(language_clean)[1]/dim(pat_cohort)[1])`.

```{r top_languages}
language_clean %>%
  group_by(language) %>%
  summarise(count=n(), .groups='drop') %>%
  arrange(desc(count)) %>%
  head(10) %>%
  kable(caption = 'Top ten languages in patient cohort') %>% 
  kable_styling()
```

### Marital status

```{r clean_marital}
marital_clean <- marital %>% 
  left_join(pat_cohort %>% select(pat_id, index_enc_date), by='pat_id') %>%
  mutate(margin = difftime(change_time, index_enc_date, unit='days'),
         old_marital_status = case_when(grepl('NULL|Unknown', old_marital_status)~NA,
                                        TRUE~old_marital_status),
         new_marital_status = case_when(grepl('NULL|Unknown', new_marital_status)~NA,
                                        TRUE~new_marital_status),) %>%
  group_by(pat_id) %>%
  filter(min(abs(margin)) == abs(margin)) %>%
  ungroup() %>%
  # if either is missing take the one that isn't missing, otherwise take according to date
  mutate(marital_status_baseline = case_when(is.na(old_marital_status) |
                                               is.na(new_marital_status)~
                                               coalesce(new_marital_status, old_marital_status),
                                             index_enc_date < change_time~old_marital_status, 
                                             index_enc_date >= change_time~new_marital_status),
         marital_status_final = case_when(marital_status_baseline %in% 
                                            c('Single', 'Divorced', 'Widowed', 'Legally Separated') ~
                                            'Unpartnered',
                                          marital_status_baseline %in% 
                                            c('Married', 'Partner', 'Significant Other') ~ 'Partnered',
                                          TRUE~NA))
```

```{r check_unique_marital}
check_unique(marital_clean)
```

Overall, we can extract marital status at baseline for `r print_percent(dim(marital_clean)[1]/dim(pat_cohort)[1])`.

### Nativity/Immigration Status

```{r clean_nativity}
nativity_clean <- lang_nativity %>% 
  select(pat_id, country_of_origin, us_citizen_yn, permanent_resident_yn) %>%
  mutate(across(us_citizen_yn:permanent_resident_yn, ~as.factor(.)),
         country_of_origin_clean = ifelse(grepl('Refused|Unknown', country_of_origin), NA,
                                          country_of_origin),
         nativity = case_when(country_of_origin_clean != 'United States of America'~'non-US',
                              permanent_resident_yn == 'Y' ~ 'non-US', 
                              us_citizen_yn == 'N' ~ 'non-US', 
                              country_of_origin_clean == 'United States of America'~'US', 
                              TRUE~NA),
         nativity = as.factor(nativity))
```

```{r check_unique_nativity}
check_unique(nativity_clean)
```

`r length(unique(lang_nativity$pat_id[which(!is.na(lang_nativity$country_of_origin))]))` patients report a country of origin in their EHR. `r length(unique(lang_nativity$pat_id[which(!is.na(lang_nativity$permanent_resident_yn))]))` patients report a permanent resident status in their EHR. `r length(unique(lang_nativity$pat_id[which(!is.na(lang_nativity$us_citizen_yn))]))` patients report a citizenship status in their EHR. 

Overall, we can extract nativity for `r print_percent(length(which(!is.na(nativity_clean$nativity)))/dim(pat_cohort)[1])`.

### BMI

```{r clean_bmi}
bmi_clean <- enc_info_baseline %>% 
  select(pat_id, bmi, enc_date) %>%
  distinct() %>%
  mutate(bmi_clean = as.numeric(bmi),
         bmi_clean = case_when(bmi_clean>10000~bmi_clean/1000,
                               bmi_clean>1000~bmi_clean/100,
                               bmi_clean>100~bmi_clean/10,
                               TRUE~bmi_clean)) %>%
  filter(!is.na(bmi_clean)) %>%
  inner_join(pat_cohort %>% select(pat_id, index_enc_date), by='pat_id') %>%
  mutate(margin = difftime(enc_date, index_enc_date, unit='days')) %>%
  group_by(pat_id) %>%
  filter(min(abs(margin)) == abs(margin)) %>%
  ungroup() 

# remove outliers (outside of 1.5 times IQR)
upper <- quantile(bmi_clean$bmi_clean, 0.75) + (1.5*IQR(bmi_clean$bmi_clean, na.rm=TRUE))
lower <- quantile(bmi_clean$bmi_clean, 0.25) - (1.5*IQR(bmi_clean$bmi_clean, na.rm=TRUE))
```

There are `r length(which(bmi_clean$bmi_clean > upper | bmi_clean$bmi_clean < lower))` BMI observations that are more than 1.5 times greater or 1.5 times less than the IQR and thus deemed outliers and set to NA.

```{r}
bmi_clean$bmi_clean[which(bmi_clean$bmi_clean > upper | bmi_clean$bmi_clean < lower)] <- NA
```

Some patients have more than one BMI at baseline so I take the average of these values to derive their baseline BMI.

```{r unique_bmi_avg}
bmi_unique <- bmi_clean %>% 
  group_by(pat_id) %>% 
  arrange(pat_id) %>%
  summarise(bmi_baseline = mean(bmi_clean), .groups='drop')
```

```{r check_unique_bmi}
check_unique(bmi_unique)
```

```{r}
summary(bmi_unique$bmi_baseline)
```


There are `r length(unique(bmi_unique$pat_id[which(!is.na(bmi_unique$bmi_baseline))]))` patients with a clean BMI at baseline which is `r print_percent(length(unique(bmi_unique$pat_id[which(!is.na(bmi_unique$bmi_baseline))]))/dim(pat_cohort)[1])`. 

### Adenomyosis

Adenomyosis will be determined if they have (1) an adenomyosis code which was `determined by biopsy` (2) or at least two codes. I will add a flag for those who have one code that does not meet either conditions.

```{r clean_adeno}
adeno_dx <- dx_outcomes %>% 
  filter(grepl('adenomyosis', tolower(dx_name)) & dx_date < '2023-08-01') %>%
  group_by(pat_id) %>%
  summarise(adeno_count = n(),
            adeno_dx_biopsy = sum(dx_name == 'Adenomyosis of uterus determined by biopsy')>=1,
            first_adeno_dx_date = min(as.Date(dx_date, '%Y-%m-%d'), na.rm=TRUE),
            .groups='drop') %>%
  mutate(adeno_final = case_when(adeno_count >= 2 | adeno_dx_biopsy ~ 'Yes',
                                 TRUE~'Flag'),
         first_adeno_dx_date = case_when(is.infinite(first_adeno_dx_date)~NA, TRUE~first_adeno_dx_date))

summary(adeno_dx)
```

Join to patient cohort and add 'No' to those with NA for `adeno_final`. 

```{r join_adeno_pat}
adeno_cohort <- pat_cohort %>% 
  select(pat_id, index_enc_date) %>%
  left_join(adeno_dx, by='pat_id') %>%
  mutate(adeno_ever = ifelse(is.na(adeno_final), 'No', adeno_final),
         adeno_fu = adeno_final == 'Yes' & first_adeno_dx_date > index_enc_date,
         adeno_baseline = adeno_final == 'Yes' & first_adeno_dx_date <= index_enc_date)
```

```{r check_unique_adeno}
check_unique(adeno_cohort)
```

There are `r length(which(adeno_cohort$adeno_ever == 'Yes'))` patients with an adenomyosis diagnosis at any point and `r length(which(adeno_cohort$adeno_baseline))` patients who are diagnosed with adenomyosis prior to baseline and `r length(which(adeno_cohort$adeno_fu))` patients who are diagnosed with adenomyosis during follow-up.

### {.unnumbered}

## 2: Explore Distributions of covariates {.tabset}

```{r combine_covars}
pat_cohort_covars <- pat_cohort %>%
  select(pat_id, age_20160801, hcu_baseline, hcu_fu, site_baseline) %>%
  left_join(employment_final %>% rename(employ_margin = margin, employ_source = source)
            , by='pat_id') %>%
  left_join(insur_clean_unique %>% select(-enc_date), by='pat_id') %>%
  left_join(ART_clean, by='pat_id') %>%
  left_join(race_ethnic_final, by='pat_id') %>%
  left_join(hc_baseline_clean, by='pat_id') %>%
  left_join(parity_clean, by='pat_id') %>%
  left_join(adeno_cohort %>% select(-index_enc_date), by='pat_id') %>%
  left_join(language_clean %>% select(pat_id, language_eng_sp, language_eng), by='pat_id') %>%
  left_join(marital_clean %>% select(pat_id, marital_status_final), by='pat_id') %>%
  left_join(bmi_unique, by='pat_id') %>%
  left_join(nativity_clean %>% select(pat_id, nativity), by='pat_id')
```

```{r check_unique_covars}
check_unique(pat_cohort_covars)
```

### Continuous variables

```{r cont_table, results='asis'}
cont_labs <- list(age_20160801 = 'Age (years)', 
                  hcu_baseline = 'Healthcare Utilization (baseline)', 
                  hcu_fu = 'Healthcare Utilization (follow-up)', 
                  bmi_baseline = 'BMI (kg/m^2)')
summary(tableby(~age_20160801 + hcu_baseline + hcu_fu + bmi_baseline, data=pat_cohort_covars),
        labelTranslations = cont_labs)
```

```{r cont_distributions, warning=FALSE}
cont_df <- pat_cohort_covars[,c('age_20160801','hcu_baseline', 'hcu_fu','bmi_baseline')]
list <-lapply(1:ncol(cont_df),
              function(col) ggplot2::qplot(cont_df[[col]],
                                           geom = "histogram",
                                           xlab = cont_labs[[col]],
                                           binwidth = 1)+ theme_bw()) 
cowplot::plot_grid(plotlist = list)
```

### Sociodemographic variables

```{r ses_table, results='asis'}
ses_labs <- list(employ_simple_final = 'Employment status', 
                 insur_status = 'Insurance status', 
                 race_ethnic_final = 'Race/Ethnicity', 
                 language_eng_sp = 'Preferred Language',
                 marital_status_final = 'Marital status',
                 parity_binary = 'Parity',
                 nativity = 'Nativity',
                 site_baseline = 'Hospital Site')
summary(tableby(~employ_simple_final + insur_status + race_ethnic_final + language_eng_sp + 
                  marital_status_final + parity_binary + nativity + site_baseline, data=pat_cohort_covars, 
                na.action = na.tableby(FALSE)), labelTranslations = ses_labs)
```

This is a cross-tabulation of race and ethnicity if we do not merge the two variables. 
```{r race_ethnic_crosstab, results='asis'}
# look at cross-tab between race and ethnicity
race_ethnic_final %>%
  tableby(formula=ethnicity_final~race_final, data=., test=FALSE) %>%
  summary()
```

### ART & HC use

```{r other_table, results='asis'}
other_labs <- list(ART_use_baseline = 'ART Use prior to baseline', 
                 ART_use_fu = 'ART Use during follow-up', 
                 HC_status = 'Hormonal Contraceptive use',
                 adeno_fu = 'Adenomyosis Dx during follow-up',
                 adeno_baseline = 'Adenomyosis Dx prior to baseline')
# make all NA's FALSE (assumption)
pat_cohort_covars <- pat_cohort_covars %>%
  mutate(ART_use_baseline = ifelse(is.na(ART_use_baseline), FALSE, ART_use_baseline),
         ART_use_fu = ifelse(is.na(ART_use_fu), FALSE, ART_use_fu),
         HC_status = ifelse(is.na(HC_status), FALSE, HC_status),
         adeno_fu = ifelse(is.na(adeno_fu), FALSE, adeno_fu),
         adeno_baseline = ifelse(is.na(adeno_baseline), FALSE, adeno_baseline))
summary(tableby(~ART_use_baseline + ART_use_fu + HC_status + adeno_fu + adeno_baseline, data=pat_cohort_covars),
        labelTranslations = other_labs)
```

### Site by other characteristics

```{r site_descriptives, results='asis'}
summary(tableby(site_baseline~employ_simple_final + insur_status + race_ethnic_final + language_eng_sp + 
                  marital_status_final + parity_binary + nativity, data=pat_cohort_covars, 
                na.action = na.tableby(FALSE)), labelTranslations = ses_labs)
```

Patients who only attend outpatient clinics in their baseline year appear to most closely resemble Tisch patients. They are predominantly privately insured, employed, non-Hispanic White (highest proportion of all sites), English speakers, and native (although among the highest missingness for all SES variables).

### {.unnumbered}

## 3: Explore Missingness of covariates {.tabset}

### Percent missing per variable

```{r missingness_percent}
gg_miss_var(pat_cohort_covars %>% 
              select(-c(pat_id, employ_source, employ_margin, employ_clean, parity_final, prior_delivery, race_final,
                        ethnicity_final,contains('date'), HC_type, adeno_count, adeno_dx_biopsy, first_adeno_dx_date, 
                        adeno_final)), 
            show_pct = TRUE)
```

Because nativity missingess is so high, we will not use it for future missingness descriptives 

### Missingness pattern across variables

```{r missingness_pattern}
gg_miss_upset(pat_cohort_covars %>% 
                select(-c(pat_id, employ_source, employ_margin, parity_final, prior_delivery,
                          employ_clean, race_final, ethnicity_final, nativity, adeno_final,
                          contains('date'), HC_type, adeno_count, adeno_dx_biopsy, first_adeno_dx_date)))
```

```{r insurance_language_missing, results='asis'}
summary(tableby(language_eng_sp~insur_status, data=pat_cohort_covars, 
                na.action = na.tableby(FALSE)), labelTranslations = ses_labs)
```

Spanish speakers have a higher proportion of missing insurance (48%) vs. English (3%) vs. Other (12%). Therefore, having missing insurance does appear to be associated with being a Spanish speaker. 

### Complete case descriptives

```{r complete_case_pattern, results='asis'}
pat_cohort_covars$complete <- complete.cases(pat_cohort_covars[,c("insur_status", 
                                                                  "race_ethnic_final",
                                                                  "language_eng_sp",
                                                                  "marital_status_final",
                                                                  "bmi_baseline", 
                                                                  "hcu_baseline", 
                                                                  "site_baseline",
                                                                  "employ_simple_final",
                                                                  "parity_binary",
                                                                  "adeno_fu", 
                                                                  "adeno_baseline")])

summary(tableby(complete ~ site_baseline + age_20160801 + bmi_baseline + parity_binary + insur_status +
                  race_ethnic_final + language_eng_sp + marital_status_final + employ_simple_final +
                  ART_use_baseline + HC_status + hcu_baseline + adeno_fu + adeno_baseline, 
                data=pat_cohort_covars, na.action = na.tableby(FALSE)),
        labelTranslations = c(cont_labs, ses_labs, other_labs))
```

In terms of notable differences, incomplete cases are more likely to: 

- have private insurance 
- speak English
- be White
- not use hormonal contraceptives

### {.unnumbered}

```{r}
## write out final table with covariates
write.csv(pat_cohort_covars, 'Data/Derived/clean_covariates.csv', row.names=FALSE)
write.csv(race_ethnic_dum, 'Data/Derived/clean_race_ethnicity_dummy.csv', row.names=FALSE)
```