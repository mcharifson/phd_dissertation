---
title: "2.012_define_UF"
author: "Mia Charifson"
date: "2024-03-15"
output: html_document:
  df_print: paged
  code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_knit$set(root.dir = '/Users/miacharifson/Library/CloudStorage/OneDrive-NYULangoneHealth/Charifson Dissertation/')

library(tidyverse)
library(ggplot2)
library(lubridate)
library(tableone)
library(arsenal)
library(readxl)
library(ggpubr)
library(corrplot)
library(data.table)
```

# 2.0. Data input & set-up

Load in all tables
```{r load}
pat_cohort <- read.csv('Data/Derived/pat_cohort_w_censoring.csv') 
uf_endo <- read.csv('Data/Epic/table3_dx_outcomes_new_20240304.csv')
uf_endo_filled_dates <-read.csv('Data/Epic/table3_dx_outcomes_date_filled_20240304.csv')
imaging_dx <- read.csv('Data/Epic/table3_dx_imaging.csv') 
imaging_orders <- read.csv('Data/Epic/table4_proc_imaging.csv') 
surgery_orders <- read.csv('Data/Epic/table4_proc_surgery.csv') 
surgery_records <- read.csv('Data/Epic/table4_surgery_surgical_dx.csv')
```

Subset tables to the eligible cohort
```{r subset_inputs}
# Combine tables that need combining
uf_endo_cohort <- uf_endo %>%
  mutate(dx_date = strptime(dx_date, "%Y-%m-%d %H:%M:%S")) %>%
  ## remove those missing a dx date
  filter(!is.na(dx_date)) %>%
  ## add in filled dx_date where missing
  bind_rows(uf_endo_filled_dates %>% 
              filter(!is.na(dx_date)) %>%
              mutate(dx_date_filled = strptime(dx_date_filled, "%Y-%m-%d %H:%M:%S"),
                     dx_date = strptime(dx_date, "%Y-%m-%d %H:%M:%S")) %>%
              mutate(dx_date = case_when(is.na(dx_date)~dx_date_filled, TRUE~dx_date),
                     pat_enc_csn_id = as.character(pat_enc_csn_id))) %>%
  # fill in missing index_enc_date
  inner_join(pat_cohort %>% select(pat_id, index_enc_date), by = 'pat_id')
  
## combine all imaging
imaging_all <- imaging_dx %>%
  mutate(imaging_date = strptime(dx_date, "%Y-%m-%d %H:%M:%S")) %>%
  #mutate(pat_enc_csn_id = as.numeric(pat_enc_csn_id)) %>%
  mutate(event_name = dx_name,
         event_type = paste0('Imaging-', dx_type)) %>%
  select(pat_id, imaging_date, event_name, event_type) %>%
  bind_rows(imaging_orders %>% 
              mutate(imaging_date = as.Date(ordering_date)) %>%
              mutate(event_name = procedure_name,
                     event_type = 'Imaging Order') %>%
              select(pat_id, imaging_date, event_name, event_type)) %>%
  filter(pat_id %in% pat_cohort$pat_id)

## combine all surgery
surgery_all <- surgery_records %>%
  mutate(surgery_date = strptime(surgery_date, "%Y-%m-%d %H:%M:%S")) %>%
  full_join(surgery_orders %>% mutate(surgery_date = as.Date(ordering_date)), 
            by=c('pat_id', 'pat_enc_csn_id', 'surgery_date', 'procedure_name',
                                 'procedure_code_type', 'procedure_code')) %>%
  mutate(type = ifelse(!is.na(performed), 'Surgery record', 'Surgery order')) %>%
  select(-ordering_date) %>%
  filter(pat_id %in% pat_cohort$pat_id)
```

Verify there are no cases with a Dx prior to index encounter
```{r check_no_prior_dx, eval=FALSE}
# there should be no UF/Endo diagnoses prior to their index enc
length(which(uf_endo_cohort$dx_date[uf_endo_cohort$icd10 != 'N80.03'] < uf_endo_cohort$index_enc_date[uf_endo_cohort$icd10 != 'N80.03']))

# look at these patients
#uf_endo_cohort %>% filter(icd10 != 'N80.03' & dx_date <= index_enc_date) %>% View()
```

Collapse to unique dates for each input type (dx, imaging, surgery)
```{r subset_unique_dates}
uf_other_codes <- c('D21.9', 'O34.10', 'O34.11', 'O34.12', 'O34.13', 'IMO0001', 'N93.9', 'D28.1', 'O46.8X1')
uf_names <- 'fibroid|leiomyoma|uterine myoma|uterine fibromyoma'

uf_dx_unique <- uf_endo_cohort %>% 
  filter(!is.na(dx_date)) %>%
  filter(grepl('D25', icd10) | (icd10 %in% uf_other_codes & grepl(uf_names, tolower(dx_name)))) %>%
  rename(date=dx_date) %>%
  select(-referral_id, -icd10, -dx_date_filled, -pat_enc_csn_id) %>%
  group_by(pat_id, date) %>%
  summarise(event_name = paste0(unique(dx_name), collapse=', '),
            event_type = paste0(unique(dx_type), collapse=', '),
            .groups='drop')

imaging_unique <- imaging_all %>% 
  mutate(date=as.Date(imaging_date)) %>%
  group_by(pat_id, date)  %>%
  summarise(event_name = paste0(unique(event_name), collapse=', '),
            event_type = paste0(unique(event_type), collapse=', '),
            .groups='drop')

surgery_unique <- surgery_all %>% 
  mutate(date = as.Date(surgery_date)) %>%
  group_by(pat_id, date) %>%
  summarise(event_name = paste0(unique(procedure_name), collapse=', '),
            event_type = paste0(unique(type), collapse=', '),
            .groups='drop')
```

Bind all inputs together
```{r final_inputs}
uf_all_long <- bind_rows(uf_dx_unique, imaging_unique, surgery_unique) %>%
  distinct() %>%
  arrange(pat_id, date)

n_uf_raw <- length(unique(uf_dx_unique$pat_id))
```

There are `r n_uf_raw` patients who have any UF Dx code added to their EHR at some point during follow-up.


# 2.1. Derive variables related to UF definition {.tabset}

Variable list: 

- First diagnosis information: date, type, name (3)
- Diagnosis count information: all, referral, medical_hx, all_medical_hx (4)
- Diagnosis procedure information (for surgical and imaging): ever, confirmed w/in 6 months, confirmed w/ prevalent Dx ever, Dx code w/in 6 months before (4x2)
- Meta diagnosis information: ever confirmed, first confirmation date, first confirmation type, all medical_hx, any locations, first date of location, ever related to pregnancy (UF only), first Dx after partial LTFU (7)

*Total number of variables: 22*

## First diagnosis information

Extract variables
```{r uf_first_dx}
uf_first_dx <- uf_endo_cohort %>% 
  filter(!is.na(dx_date)) %>%
  filter(grepl('D25', icd10) | (icd10 %in% uf_other_codes & grepl(uf_names, tolower(dx_name)))) %>%
  group_by(pat_id) %>%
  filter(dx_date==min(dx_date)) %>%
  summarise(first_dx_date = mean(dx_date),
            first_dx_type = paste0(unique(dx_type), collapse = ';'),
            first_dx_name = paste0(unique(dx_name), collapse = ';'),
            .groups='drop') %>%
  left_join(pat_cohort %>% 
              select(pat_id, index_enc_date, final_censor_date, final_censor_type, ltfu_status, ltfu_reengage_date)
            , by="pat_id") %>%
  mutate(time_to_first_dx = difftime(first_dx_date, index_enc_date, units="days"))
```

Plot distribution for date of first diagnosis
```{r uf_first_dx_plot}
uf_first_dx %>%
  group_by(first_dx_date) %>%
  summarise(count=n(), .groups='drop') %>%
  mutate(cumulative_count = cumsum(count)) %>%
  ggplot(data=., aes(x=first_dx_date, y=cumulative_count)) +
  geom_line() +
  ylab('Cumulative Count of Patients Diagnosed with UF') +
  xlab('Date of Diagnosis') +
  theme_bw()
```

Plot distribution of time to first diagnosis
```{r time_to_first_uf_dx_plot}
uf_first_dx %>%
  # only for those diagnosed under 6 months
  ggplot(data=., aes(x=time_to_first_dx)) +
  geom_histogram(fill='lavender', color='black', binwidth=30) +
  xlab('Days between Index Encounter and First UF Dx') +
  theme_bw()
```

Table of first diagnosis type
```{r uf_first_dx_table}
uf_first_dx %>%
  mutate(medical_hx = case_when(grepl('Medical History', first_dx_type)~TRUE, TRUE~FALSE),
         encounter = case_when(grepl('Encounter Diagnosis', first_dx_type)~TRUE, TRUE~FALSE),
         problem_list = case_when(grepl('Problem List', first_dx_type)~TRUE, TRUE~FALSE),
         hospital_dx = case_when(grepl('Hospital Account Diagnosis', first_dx_type)~TRUE, TRUE~FALSE),
         referral_dx = case_when(grepl('Referral Diagnosis', first_dx_type)~TRUE, TRUE~FALSE)) %>%
CreateTableOne(data=., vars = c('referral_dx', 'encounter', 'medical_hx', 'problem_list', 'hospital_dx'))
```
These sum to more than 100% because patients can get one code type dropped on the same day as another (i.e. a referral Dx and an encounter Dx on the same day).

There are `r length(which(uf_first_dx$time_to_first_dx <= 180))` patients diagnosed in their first 6 months of follow-up.


## Diagnosis count variables

Extract diagnosis count variables
```{r uf_multiple_dx}
uf_dx_count <- uf_all_long %>% 
  mutate(referral_dx=ifelse(grepl('Referral Diagnosis', event_type), TRUE, FALSE),
         medical_hx=ifelse(event_type == 'Medical History', TRUE, FALSE)) %>%
  group_by(pat_id) %>%
  summarise(dx_count = sum(grepl('Diagnosis|Problem|History', event_type)), 
            referral_count = sum(referral_dx),
            all_medical_hx = ifelse(n()==sum(medical_hx), TRUE, FALSE),
            .groups='drop')
```

Plot the distribution of counts of diagnoses
```{r uf_dx_count_plot}
ggplot(data=uf_dx_count, aes(x=dx_count)) + 
  geom_histogram(fill='lightblue', color='black', binwidth = 5) +
  xlab('Number of UF Dx per patient') +
  theme_bw()
```
`r length(which(uf_dx_count$dx_count == 1))` cases have only 1 UF diagnosis code in their records.
This is `r round(length(which(uf_dx_count$dx_count == 1))/n_uf_raw, 2)*100`% of UF patients. Some of these may be confirmed below via other hints.

Relative frequency of first diagnosis type when they only have one diagnosis code
```{r uf_only_one_dx_table}
uf_all_long %>%
  filter(pat_id %in% uf_dx_count$pat_id[which(uf_dx_count$dx_count == 1)]) %>%
  filter(grepl('Diagnosis|History|Problem', event_type)) %>%
  mutate(medical_hx = case_when(grepl('Medical History', event_type)~TRUE, TRUE~FALSE),
         encounter = case_when(grepl('Encounter Diagnosis', event_type)~TRUE, TRUE~FALSE),
         problem_list = case_when(grepl('Problem List', event_type)~TRUE, TRUE~FALSE),
         hospital_dx = case_when(grepl('Hospital Account Diagnosis', event_type)~TRUE, TRUE~FALSE),
         referral_dx = case_when(grepl('Referral Diagnosis', event_type)~TRUE, TRUE~FALSE)) %>%
  CreateTableOne(data=., test=FALSE,
                 vars = c('referral_dx', 'encounter', 'medical_hx', 'problem_list', 'hospital_dx'))
```
Of those with only 1 UF diagnosis code, most are encounter diagnoses and not medical history diagnoses which is promising. The 277 patients with only one diagnosis code, that is a medical history, are going to be difficult to place and may be prevalent cases. 

Table showing censoring among those with only one diagnosis code
```{r}
tab <- uf_first_dx %>%
  filter(pat_id %in% uf_dx_count$pat_id[which(uf_dx_count$dx_count == 1)]) %>%
  filter(first_dx_date > final_censor_date & final_censor_type == 'LTFU') %>%
  mutate(ltfu_status = factor(ltfu_status)) %>%
  CreateTableOne(data=., vars='ltfu_status')

print(tab, showAllLevels=TRUE)
```
Most patients with only one UF dx who are also are diagnosed after they are partially LTFU (they are likely these medical history diagnosis after re-engage patients).

Table of disgnosis count and first type among those who are completely LTFU
```{r}
tab <- uf_first_dx %>%
  left_join(uf_dx_count, by='pat_id') %>%
  filter(first_dx_date > final_censor_date & ltfu_status == 'complete') %>%
  mutate(dx_count = factor(dx_count)) %>%
  CreateTableOne(data=., vars=c('dx_count', 'first_dx_type'), test=FALSE)

print(tab, showAllLevels=TRUE)
```
For complete LTFU patients diagnosed after censoring, most of them only have one diagnosis code. They are also predominantly encounter/referral diagnoses and hospital account diagnoses. Some are medical history diagnoses as well. 

Derive only medical history cases (hint for prevalent case)
```{r medical_hx_only_hint}
# look for patients who ONLY ever have medical history code drops (no procedures)
uf_only_medical_hx <- uf_all_long %>% 
  group_by(pat_id) %>%
  summarise(all_medical_hx = ifelse(n()==sum(event_type == 'Medical History'), TRUE, FALSE),
            .groups='drop')
```
There are `r length(which(uf_only_medical_hx$all_medical_hx))` patients for whom the only indication for UF in their EHR is via medical history codes (and no diagnostic procedures). There is a high likelihood these patients are prevalent cases who only had their health history added to their record after entry to cohort. 

Assumption: if they were diagnosed outside NYU but during follow-up, they'd have a referral diagnosis code. 

Plot age distribution among only medical history cases
```{r medical_hx_age_plot}
# are these patients generally older
pat_cohort %>%
  filter(pat_id %in% uf_only_medical_hx$pat_id[which(uf_only_medical_hx$all_medical_hx)]) %>%
  ggplot(data=., aes(x=age_20160801)) +
  geom_histogram(fill='lightyellow', color='black', binwidth=5) +
  xlab('Age at basline') +
  theme_bw()
```
Patients who only ever get UF codes dropped as medical history (and never have any procedures) are predominantly older patients (above 35 years old). I will explore the younger patients but I think in general these patients should be considered prevalent cases and exclude from the analysis. 

Look at time to first diagnosis for only medical history cases
```{r}
# time to first dx for all medical history cases
uf_first_dx %>%
  filter(pat_id %in% unique(uf_only_medical_hx$pat_id[which(uf_only_medical_hx$all_medical_hx)])) %>%
  ggplot(data=., aes(x=as.numeric(time_to_first_dx))) +
  geom_histogram(fill='lavender', color='black', binwidth=30) +
  xlab('Days between Index Encounter and First UF Dx') +
  geom_vline(xintercept = 365, color='orange') +
  theme_bw()
```
Some of these patients are surely prevalent UF cases based on the early time to first diagnosis, but there is a wide distribution as to the timing of the first diagnoses which implies that some are incident cases that for some reason only get dropped as medical history diagnoses from the start. Assumption: these represent cases diagnosed outside of NYU and then come to NYU after treatment/diagnosis. 


## Diagnostic procedure hints

Extract the time between any diagnostic procedure and the closest date of a diagnosis code
```{r procedure_dx_sequelae, warnings=FALSE}
df <- uf_all_long
setDT(df)
# indexing which rows are procedures
df$is_procedure <- grepl('Imaging|Surgery',df$event_type)
# indexing which rows are dx (ignore imaging Dx for now)
df$is_diagnosis <- grepl('Diagnosis|Problem|List|History',df$event_type) & !grepl('Imaging',df$event_type)
# rearrange so if a procedure and dx happen on the same day the procedure goes first
df <- arrange(df, pat_id, date, is_diagnosis, is_procedure)
# get the index of the next row that is a dx when the row is a procedure
df[,next_dx_index:=zoo::na.locf(NA^(!is_diagnosis)*.I, fromLast=T, na.rm=F)*NA^(!is_procedure), by=pat_id]
# find time difference between the date of procedure and the next Dx date
df <- df[,next_dx_time_interval:=difftime(date[next_dx_index], date, units="days")]
df <- df[,next_dx_name:=event_name[next_dx_index]]
df <- df[,next_dx_type:=event_type[next_dx_index]]
# check this works
#View(df)

# which are on the same day
length(which(df$next_dx_time_interval==0))
```

Plot the time margin distributions by procedure type (imaging vs. surgery)
```{r procedure_dx_time_margin}
df2 <- as.data.frame(df) %>%
  mutate(method = case_when(grepl('Surgery', event_type)~"Surgery",
                            grepl('Imaging', event_type)~"Imaging",
                            TRUE~NA))

df2 %>%
  filter(!is.na(next_dx_time_interval)) %>%
  group_by(pat_id) %>%
  filter(next_dx_time_interval == min(next_dx_time_interval, na.rm=TRUE)) %>%
  # in the case that there are multiple procedures with same margin, take the earlier one
  filter(date == min(date, na.rm=TRUE)) %>%
  ungroup() %>%
  ggplot(data=., aes(x=next_dx_time_interval/30, fill=method)) +
  xlab('Shortest Time between Dx procedure and next Dx code (months)') +
  geom_histogram(binwidth = 5) +
  facet_wrap(~method, scales = 'free_y') +
  theme_bw()
```
The graph shows the count for patients who have an UF Dx, had any diagnostic procedure performed in their EHR, and had another UF Dx code following that procedure. The earliest procedure with the shortest margin between procedure and Dx code are selected per patient. The vast majority have an imaging procedure performed and within one month another Dx code is dropped. For those with a surgical procedure chosen, they are also quickly followed with another Dx code.

Derive surgery hints for each patients
```{r surgery_hints}

```

Derive imaging hints for each patients
```{r imaging_hints}

```


## Meta-diagnosis information

Location of the fibroid
```{r}
# extract location of the UF based on Dx name if that exists
df2$location <- grepl('intramural|subserous|submucosal|subserosal|submucous|cervix|cervical', tolower(df2$event_name))
```

First date of location

Pregnancy related

Ever confirmed

First confirmation date

First confirmation type

Ever related to pregnancy (UF only)

First Dx after partial LTFU

Historical diagnosis close to fist diagnosis date

## {.unnumbered}

# 2.2. Heatmap of UF outcome hints

There are several "hints" in the EHR which might encourage confidence that a UF Dx is a true positive. They were extracted from the EHR above. Understanding how they relate to each other in our cohort can be informative of how to identify confident incident and prevalent cases.

```{r}
# subset to only those with a UF dx
uf_dx_hints <- uf_hints %>% 
  filter(uf_dx) %>% 
  select(pat_id, first_dx_referral:surgery_w_dx_after) %>%
  mutate(number_hints = rowSums(.[2:10], na.rm=TRUE))
```

```{r uf_hints_corrplot}
corrplot.mixed(cor(uf_dx_hints[,-1], use='pairwise.complete.obs'),  # Correlation matrix
               lower = "number", 
               upper = "ellipse",
               tl.pos = "lt",
               tl.col = "black") 
```
The correlation plot above visualizes the correlation between these binary UF diagnosis characteristics. For example, the presence of imaging is negatively correlated (-0.47) with the presence of surgery in someone's EHR. My interpretation here is that many patients are referred into NYU for surgery for UF but these patients are therefore much less likely to get imaging. Other important observations include:

- confirmed imaging has a positive correlation with surgery and confirmation via surgery (these are highly confident cases)
- confirmation via surgery is negatively correlated with later Dx codes after 3 months of surgery (this makes sense if we think about surgery as treatment for the condition, although recurrence is possible)
- the first dx code being a referral Dx is positively correlated with having multiple Dx codes and other referral Dx codes
- confirmation via imaging OR surgery is positively correlated with have multiple Dx codes and multiple referral Dx codes
- the hint with the weakest relationship to the overall number of hints a patient has is the presence of imaging (this makes sense since people could get imaging for any number of reasons)

```{r}
uf_dx_hints %>%
  ggplot(data=., aes(x=number_hints)) +
  geom_histogram(fill='darkseagreen2', color='black', binwidth=1) +
  xlab('Number of UF Dx Hints per patient') +
  theme_bw()
```



# 2.3. Define UF outcome according to EHR phenotypes

`Confident positive` is defined as a UF diagnosis which has some combination of the following hints (in order of confidence):
```{r}
confident_uf_dx <- uf_dx_unique %>%
  distinct(pat_id) %>%
  mutate(confident_dx = FALSE)
```

1. Confirmation of UF Dx following a diagnostic procedure (same day as procedure = most confident)
```{r confirmed_w_procedure}
# grab ids for those who have any procedure with another diagnosis code within
ids <- unique(df2$pat_id[which(df2$next_dx_time_interval <= 180)])
# change their status in dataframe and add type
confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~confident_dx),
         confirmed_via_procedure = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE))
```

2. Having a diagnostic procedure & any UF Dx after a diagnostic procedure
**Assumption: prior to surgery someone might have an unconfirmed diagnosis (unspecified location or no imaging confirmed location), but they are found and removed during surgery, later the fibroids are entered into EHR as a historical diagnosis or on problem list**
```{r confirmed_after_procedure}
ids <- unique(df$pat_id[which(grepl("Problem|History", df$event_type[df$next_dx_index]) & df$next_dx_time_interval > 180)])
## add these to the confident_dx dataframe
confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~confident_dx),
         prevalent_dx_after_procedure = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE))

#summary(confident_uf_dx)
```

3. Having location of the fibroid indicated on a diagnosis
**Assumption: the only way a location would be supplied is through some diagnostic procedure even if not noted in their charts.**
```{r confirmed_w_location}
# grab patients who have any UF diagnosis with a location
ids <- unique(df2$pat_id[which(df2$location)])
# these could still be prevalent cases but we still assume these are true cases

confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% ids~TRUE, 
                                  TRUE~confident_dx),
         location_of_fibroids = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE))
```

4. Pregnancy-related diagnoses
**Assumption: most of these are incidental fibroid diagnoses resulting from imaging related to pregnancy (confirmed by Shilpi). Many of these cases may be asymptomatic but are true incidental cases.**
```{r pregnancy_related}
# grab ids for those with a pregnancy diagnosis (not medical history as these might refer to a prior pregnancy)
ids <- unique(df$pat_id[which(!grepl("History", df$event_type) & 
                                grepl("pregnancy|partum|antenatal|antepartum", tolower(df$event_name)))])

## add these to the confident_dx dataframe
confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~confident_dx),
         pregnancy_uf_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE))
```

5. 2 or more referral diagnoses
**Assumption: if patients are being referred multiple times for UF -- this could indicate that they have strong symptomology and/or they are diagnosed by an external provider and then referred to NYU for treatment.**
```{r multiple_referrals}
ids <- uf_dx_count$pat_id[which(uf_dx_count$referral_count > 1)]

## add these to the confident_dx dataframe
confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~confident_dx),
         multiple_referral_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE))
```

6. First diagnosis is on the same date as re-engage after LTFU
**Assumption: Patients who receive their first UF Dx on the day they return to relevant care at NYU were likely diagnosed outside of NYU and return to NYU with the new incident diagnosis.**
```{r dx_after_partial_LTFU}
# people diagnosed AFTER re-engaging in relevant care post-LTFU are likely incident cases
ids <- uf_first_dx$pat_id[which(uf_first_dx$first_dx_date==uf_first_dx$ltfu_reengage_date)]

# add to the confident_dx dataframe
confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% ids~TRUE,
                                  TRUE~confident_dx),
         dx_after_partial_LTFU = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE))
```
QUESTION: Should patients diagnosed DURING partial LTFU be included here? Based on dicussion with Anais, these could be encounter diagnoses dropped for the referral (forced by Epic) but is not a confirmed diagnosis.

`Prevalent cases` can be identified via a historical diagnosis (Z86) code at or close (within 2 months) to first dx code
**Assumption: If within two months of the first dx code they also get a code that indicates 'history of endometriosis' there is a good chance that the first diagnosis code was for a prevalent diagnosis.**

```{r prevalent_cases}
## grab hx codes and record first instance
uf_hx_code <- uf_endo_cohort %>% 
  filter(grepl('Z86', icd10)) %>%
  group_by(pat_id) %>% 
  summarise(first_hx_code = min(dx_date), .groups='drop') %>%
  inner_join(uf_first_dx %>% select(pat_id, first_dx_date, first_dx_type, first_dx_name), by='pat_id') %>%
  mutate(hx_code_margin = difftime(first_hx_code, first_dx_date, unit='days'))

## look at how many are close to the date of first dx code
prevalent_ids <- unique(uf_hx_code$pat_id[which(uf_hx_code$hx_code_margin<=60)])
ids <- unique(uf_hx_code$pat_id[which(uf_hx_code$hx_code_margin>60)])

# add to the confident_dx dataframe as true negatives
confident_uf_dx <- confident_uf_dx %>%
  mutate(confident_dx = case_when(pat_id %in% c(prevalent_ids, ids)~TRUE,
                                  TRUE~confident_dx),
         no_prevalent_hx_code = case_when(pat_id %in% ids~TRUE,
                                  TRUE~FALSE),
         confident_prevalent = case_when(pat_id %in% prevalent_ids~TRUE,
                                  TRUE~FALSE))
```

## {.unnumbered}


# 2.4. Determine final case status {.tabset}

## Confident incident cases

```{r}
print(CreateTableOne(data=confident_uf_dx, includeNA=TRUE,
               vars=c('confident_dx', 'confirmed_via_procedure', 'location_of_fibroids',
                      'prevalent_dx_after_procedure','pregnancy_uf_dx', 'multiple_referral_dx',
                      'dx_after_partial_LTFU', 'no_prevalent_hx_code', 'confident_prevalent')),
      showAllLevels = TRUE)
```


## Hesitant cases (prevalent or incident)


```{r}
# grab IDs of patients who never get any procedure during follow-up
ids <- confident_uf_dx$pat_id[which(!confident_uf_dx$confident_dx)]

# grab characteristics from the procedure dataframe
procedure_info <- df2 %>%
  group_by(pat_id) %>%
  summarise(
    has_any_imaging=ifelse(sum(method=='Imaging', na.rm=TRUE)>=1, TRUE, FALSE),
    has_any_surgery=ifelse(sum(method=='Surgery', na.rm=TRUE)>=1, TRUE, FALSE),
    shortest_procedure_dx_margin = ifelse((all(is.na(next_dx_time_interval))), NA, 
                                          min(next_dx_time_interval, na.rm = TRUE)), 
    .groups='drop')
 
# join together this and other information on these patients 
df_not_confident <- uf_first_dx %>%
  left_join(uf_dx_count, by='pat_id') %>%
  left_join(procedure_info, by='pat_id') %>%
  filter(pat_id %in% ids) %>%
  mutate(first_dx_medical = grepl('Medical History', first_dx_type),
         only_one_code=ifelse(dx_count==1, TRUE, FALSE),
         time_to_first_dx=as.numeric(time_to_first_dx),
         shortest_procedure_dx_margin=as.numeric(shortest_procedure_dx_margin),) %>%
  mutate(dx_early_into_FU = ifelse(time_to_first_dx <= 180, TRUE, FALSE))

# look at overall characteristics
tab_not_confident <- CreateTableOne(data=df_not_confident, 
                                    vars=c("first_dx_medical", "dx_early_into_FU", "dx_count", "referral_count", 
                                           "all_medical_hx", "has_any_surgery", "has_any_imaging", 
                                           "shortest_procedure_dx_margin", "only_one_code"))

print(tab_not_confident, 
      nonnormal=c("dx_count", "referral_count", "shortest_procedure_dx_margin"), 
      showAllLevels = TRUE)
```

```{r not_confident_hints_corrplot}
# make correlation matrix for non-confident case characteristics
corrplot.mixed(cor(df_not_confident %>% 
                     select(dx_early_into_FU, only_one_code, referral_count, 
                            all_medical_hx, has_any_imaging, has_any_surgery), use='pairwise.complete.obs'),  
               lower = "number", 
               upper = "ellipse",
               tl.pos = "lt",
               tl.col = "black") 
```
Based on looking at this correlation matrix, the most relevant characteristics of the non-confident cases appears to be having only one code, number of referrals, and whether all dx codes are medical history. Therefore chart review will be broken down as follows:

- Only one code (n=80)
- More than one code & all medical hx codes (n=30) --> likely prevalent cases
- More than one code & NOT all medical hx codes (n=90)

Furthermore, given the relevance of referral codes, we will explore the assumption that 2 or more referral dx codes are incident cases (n=20). Finally, we will explore the assumption that first dx after partial LTFU are incident cases (n=20).

## Generate subset of non-confident cases for chart review

```{r}
set.seed(2024)
## grab random subset of cases from each group of non-confident cases
chart_review_cases <- df_not_confident %>% 
  filter(only_one_code) %>% sample_n(., 80) %>% 
  mutate(group = 'only_one_code') %>%
  bind_rows(df_not_confident %>% filter(!only_one_code) %>% sample_n(., 90) %>% 
              mutate(group = 'more_than_one_code')) %>%
  bind_rows(df_not_confident %>% filter(all_medical_hx) %>% sample_n(., 30) %>% 
              mutate(group = 'all_medical_hx')) %>%
  bind_rows(confident_uf_dx %>% filter(multiple_referral_dx) %>% sample_n(., 20) %>% 
              mutate(group = 'multiple_referrals')) %>%
  bind_rows(confident_uf_dx %>% filter(dx_after_partial_LTFU) %>% sample_n(., 20) %>% 
              mutate(group = 'dx_after_partial_LTFU')) %>%
  left_join(pat_cohort %>% select(pat_id, pat_mrn_id), by='pat_id') %>%
  select(pat_mrn_id, pat_id:group)

## write out file
write.csv(chart_review_cases, 'Data/Derived/uf_chart_review_cases.csv', row.names = FALSE)
```


## Look at censoring date and first diagnosis date for these non-confident cases

```{r}
df_not_confident %>%
  mutate(censored_before_dx = ifelse(first_dx_date >= final_censor_date, TRUE, FALSE)) %>%
  CreateTableOne(data=., var=c('final_censor_type', 'censored_before_dx'), includeNA=TRUE)
```
About 60% of non-confident cases experience some form of censoring and about 20% of these cases are diagnosed after censoring occurred. This could likely indicate more usage of other healthcare systems in which an incident UF dx occurred and then was at some point communicated back to NYU. 

Those who age out or experience menopause might be more likely to be prevalent cases -- check if they are fall into the all medical history diagnosis category. 

Finally, those who are censored via surgery may be true cases referred in for surgery with little diagnosis information in NYU EHR -- also look into these. 

```{r}
# look into those censored due to surgery
```

## {.unnumbered}


# 2.5. Finalize outcome and save files {.tabset}

## Add to patient cohort table with flag for case type

## Calculate person-time for cohort
```{r}
pat_cohort %>%
  mutate(person_years = case_when(is.na(final_censor_date)~difftime('2023-08-01',index_enc_date,units='days'),
                                  TRUE~difftime(final_censor_date,index_enc_date,units='days')),
         person_years = as.numeric(person_years)/365.25) %>%
  summarise(total_person_time = sum(person_years))
```

## Investigate censoring among those eventually diagnosed

How many patients are censored prior to their first UF diagnosis code?

`r length(which(uf_first_dx$first_dx_date > uf_first_dx$final_censor_date))` patients are censored prior to their first UF Dx code gets dropped.

How are these patients censored?

```{r}
uf_first_dx %>%
  filter(first_dx_date > final_censor_date) %>%
  CreateTableOne(data=., vars='final_censor_type')
```

The majority of them are lost to follow-up (LTFU). Of those LFTU, how many of them re-engage?

```{r}
tab <- uf_first_dx %>%
  filter(first_dx_date > final_censor_date & final_censor_type == 'LTFU') %>%
  mutate(ltfu_status = factor(ltfu_status)) %>%
  CreateTableOne(data=., vars='ltfu_status')

print(tab, showAllLevels=TRUE)
```

Very few of these patients are completely LTFU. If this was coded correctly, they should re-engage prior to their first UF diagnosis. Double checking this below...

```{r}
uf_first_dx %>%
  filter(first_dx_date > final_censor_date & final_censor_type == 'LTFU' & ltfu_status=='partial') %>%
  mutate(reengage_prior_to_dx = as.numeric(difftime(first_dx_date, ltfu_reengage_date, units='days'))) %>%
  ggplot(data=., aes(x=reengage_prior_to_dx)) +
  geom_histogram(fill='lightpink', color='black', binwidth=30) +
  xlab("Days between First UF Diagnosis date and Re-Engagement in relevant care") +
  theme_bw()
```

The graphs above shows that some patients received their first UF diagnosis sometime between the last known relevant care encounter prior to LTFU (3 years of no relevant care) and the next time they have relevant care (sometime greater than 3 years later). This would suggest these patients are still receiving SOME kind of care that allowed them to get a diagnosis code dropped but we do not consider this relevant care in our definition. 

```{r}
uf_first_dx %>%
  filter(first_dx_date > final_censor_date & final_censor_type == 'LTFU') %>%
  mutate(medical_hx = case_when(grepl('Medical History', first_dx_type)~TRUE, TRUE~FALSE),
         encounter = case_when(grepl('Encounter Diagnosis', first_dx_type)~TRUE, TRUE~FALSE),
         problem_list = case_when(grepl('Problem List', first_dx_type)~TRUE, TRUE~FALSE),
         hospital_dx = case_when(grepl('Hospital Account Diagnosis', first_dx_type)~TRUE, TRUE~FALSE),
         referral_dx = case_when(grepl('Referral Diagnosis', first_dx_type)~TRUE, TRUE~FALSE)) %>%
  CreateTableOne(data=., test=FALSE,
                 strata = 'ltfu_status', 
                 vars = c('referral_dx', 'encounter', 'medical_hx', 'problem_list', 'hospital_dx'))
```
Many of these diagnoses that occur after complete or partial diagnoses are encounter diagnoses. About one-fourth are referral diagnoses which is expected and another fourth to third are medical history diagnoses which could once again be indicative of being diagnosed outside of NYU and indicating this new diagnosis upon return to care at NYU or at 'irrelevant' care at NYU.

## Save both dataframes (updated pat_cohort & all_uf_hints)
